% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/qsOpt.R
\name{qscoring}
\alias{qscoring}
\title{Quasi-scoring iteration}
\usage{
qscoring(qsd, x0, opts = list(), Sigma = NULL, ..., check = TRUE,
  cvm = NULL, Iobs = TRUE, verbose = FALSE)
}
\arguments{
\item{qsd}{object of class \code{\link{QLmodel}}}

\item{x0}{(named) numeric vector, the starting parameter}

\item{opts}{quasi-scoring options, see details}

\item{Sigma}{a prespecified constant variance matrix estimate}

\item{...}{further arguments passed to the function \code{\link{covarTx}}}

\item{check}{logical, \code{TRUE} (default), whether to check input arguments}

\item{cvm}{optional, either list of covariance models of the statistics for cross-validation based estimation of prediction variances of the statistics or
of class \code{cv} or list of cross-validation models of class \code{cvfull} of the QL model \code{qsd} for computation of the quasi-deviance
and error estimation of the quasi-score approximation w.r.t the kriging prediction models (see \code{\link{prefitCV}})}

\item{Iobs}{optional, if \code{TRUE} (default), compute observed quasi-information by finite difference approximations of the quasi-score vector}

\item{verbose}{logical, \code{FALSE} (default), otherwise print intermediate output}
}
\value{
List of results of quasi-scoring iteration with elements:
 \item{convergence}{ integer, why scoring iterations stopped}
 \item{message}{ string, corrsponding to `\code{convergence}`}
 \item{iter}{ number of iterations}
 \item{value}{ quasi-deviance value}
 \item{par}{ solution vector}
 \item{score}{ quasi-score vector}
 \item{I}{ quasi-information matrix}
 \item{start}{ starting point}
 \item{method}{ simply: "\code{qscoring}"}
 \item{criterion}{ equal to "\code{qle}"}
}
\description{
The function numerically solves the quasi-score equation by a root finding algorithm similar to Fisher's scoring method.
}
\details{
The function implements a step-length controlled quasi-scoring iteration with simple bound
 constraints (see also [1,3]) specifically tailored for quasi-likelihood parameter estimation. Due to the typical
 nonconvex nature of the (unknown and not further specified) quasi-likelihood function as an objective
 function one needs some kind of globalization strategy in order to stabilize the descent step and to avoid a premature
 termination. Therfore, we use the quasi-deviance function as a monitor function (see vignette) though it does not
 inherit all of the appreciable properties of a true objective function such as among others, for example,
 identifying appropriate descent directions. However, these are general numerical obsticles in case of pure root
 finding algorithms and need to be addressed elsewhere. 
 
 \subsection{Quasi-scoring under uncertainty}{ 
 The quasi-scoring iteration includes both kinds of prediction variances, kriging-based and those derived from a cross-validation (CV) approach,
 which account for the additinal uncertainty induced by the quasi-score approximation model. By default kriging variances
 are included in the computation during all iterations through the inverse quasi-information matrix as part of the search direction. If fitted covariance models `\code{cvm}` are supplied by the user
 in advance (see \code{\link{prefitCV}}), the variances of prediction errors of each statistic are separately evaluated by the proposed CV
 approach for each new point. For the price of relatively high computational costs those prediction variances
 are intended to increase the robustness against false roots due to simulation and approximation errors of the quasi-score function.#'   
 }

 The following algorithmic options, which can be set by `\code{opts}`, are available:
 \itemize{
  	\item{\code{ftol_stop}:}{ minimum value of the quasi-deviance for stopping the scoring iteration}
		\item{\code{ftol_abs}:}{ minimum value of the quasi-deviance which is used as a reference value for a local minimizer or if the minimum steplength is reached}
		\item{\code{xtol_rel}:}{ minimum relative stepsize between consecutive estimates }
		\item{\code{step_tol}:}{ tolerance of two scaled consecutive steps }
		\item{\code{grad_tol}:}{ upper bound on the quasi-score vector components,
				 testing for a local minimum of the quasi-deviance in case of a line search failure}
		\item{\code{score_tol}:}{ upper bound on the quasi-score vector components, testing for an approximate root}
     \item{\code{maxiter}:}{ maximum allowed number of iterations}
		\item{\code{xscale}:}{ numeric, default is vector of 1, typical magnitudes of vector components of `\code{x0}`, e.g. the order of upper bounds of the parameter space}
     \item{\code{fscale}:}{ numeric, default is vector of 1, typical magnitudes of quasi-score components}
}
}
\examples{
data(normal)
QS <- qscoring(qsd,x0=c("mu"=3.5,"sigma"=0.5),
         opts=list("score_tol"=1e-4))

}
\seealso{
\code{\link{prefitCV}}
}
\author{
M. Baaske
}
