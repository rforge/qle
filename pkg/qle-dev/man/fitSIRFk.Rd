% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/covariance.R
\name{fitSIRFk}
\alias{fitSIRFk}
\title{Covariance model fitting}
\usage{
fitSIRFk(qldata, set.var = TRUE, var.type = "wcholMean",
  var.opts = list(var.sim = 1e-06), intrinsic = FALSE, ...,
  controls = list(), fun = getOption("qle.fork", "lapply"), cl = NULL,
  verbose = FALSE)
}
\arguments{
\item{qldata}{object of class \code{QLdata}, a data frame from \code{\link{setQLdata}}}

\item{set.var}{if \code{TRUE} (default), set simulation variances as local nugget variances}

\item{var.type}{name of variance matrix approximation type (see \code{\link{covarTx}})}

\item{var.opts}{list of arguments passed to \code{\link{setCovModel}}
(only for `\code{var.type}` equal to "\code{kriging}")}

\item{intrinsic}{logical, if \code{TRUE}, use a nugget variance estimate for kriging
approximations of the variance matrix}

\item{...}{arguments passed to \code{\link{setCovModel}}}

\item{controls}{list of control parameters passed to \code{\link[nloptr]{nloptr}} minimization function}

\item{fun}{either "\code{lapply}" (default) or "\code{mclapply}" for parallel processing}

\item{cl}{cluster object, \code{NULL} (default), see \code{\link[parallel]{makeCluster}}}

\item{verbose}{if \code{TRUE}, print intermediate information}
}
\value{
List of fitted covariance models for kriging the 
 sample means of statistics named `\code{covT}` and optionally
 the variance matrix of statistics, `\code{covL}`. The object also stores
 the reml optimization parameters `\code{controls}`.
}
\description{
Fit a generalized covariance model to simulation data
}
\details{
The function estimates the parameters of the covariance model `\code{sirfk}` by default using REML for kriging
  the statistics and kriging the variance matrix of statistics only if `\code{var.type}` does not equal "\code{const}".
  We use a (self-similar) intrinsic random function of order \eqn{k} (see, e.g. [1]) with \eqn{k=1,2} for all statistics
  (including a default quadratic drift term, \eqn{k=2}). The user can also define different covariance models for each statistic
  separately (see \code{\link{setCovModel}}). If the user prefers to fit all statistics by other covariance models, then these
  can be specified by their names in `\code{model}`. Further arguments are passed to \code{\link{setCovModel}}
  by `\code{...}`.
  		
  The argument `\code{var.opts}` only sets the options for the covariance models for kriging the variance matrix.
  The optional arguments `\code{var.sim}` and `\code{var.opts$var.sim}` set the local or global
  \dfn{nugget} values for each sample point depending on `\code{set.var}`. Both arguments (passed to \code{\link{setCovModel}})
  must be data frames of lengths corresponding to the number of covariance models of statistics and, respectively, to the number of
  \emph{Cholesky} decompositions in case of kriging the variance matrix. If `\code{set.var}` is \code{TRUE}, then the values in
 `\code{var.sim}` are used as fixed `nugget` values and replicated to match the number of sample points if required. Otherwise
  they are considered as simulation variances and hence scaled by 1/\code{nsim}, which is meaningful only for kriging the statistics.
  The same principle applies in case of kriging the variance matrix. Here the values in `\code{var.opts$var.sim}` (of length one or
  equal to the number of corresponding sample points) are used as scale factors for all Cholesky decomposed terms
  if `\code{intrinsic}` is \code{TRUE} and otherwise considered as local nugget variances. A global nugget value is estimated during
  the REML covariance parameter estimation for both cases.
	 Note that the returned object can also be constructed manually and passed as an input argument to
  \code{\link{QLmodel}} in case the user prefers to set up each covariance model separately. Also see function
  \code{\link{getQLmodel}} for an example.
}
\author{
M. Baaske
}
